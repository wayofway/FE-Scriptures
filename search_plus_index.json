{"./":{"url":"./","title":"简介","keywords":"","body":"前端四十二章经 web前端开发基础知识及技术总结分享 .gitbook-donate { display: none; } wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"前端标准与规范/html/":{"url":"前端标准与规范/html/","title":"第1节：HTML","keywords":"","body":"HTML wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"前端标准与规范/html/HTML标签.html":{"url":"前端标准与规范/html/HTML标签.html","title":"HTML标签","keywords":"","body":"HTML 标签 什么是 HTML 标签 HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，比如 和 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 常用 HTML 标签 基本 标签 说明 … 定义 HTML 文档 … 文档的信息 HTML 文档的元信息 … 文档的标题 文档与外部资源的关系 … 文档的样式信息 … 可见的页面内容 注释 文本 标签 说明 ... 标题字大小（h1~h6） ... 粗体字 ... 粗体字(强调) ... 斜体字 ... 斜体字(强调) … 居中文本 … 无序列表 … 有序列表 … 列表项目 … 超链接 定义文本字体尺寸、颜色、大小 下标 上标 换行 段落 图形 标签 说明 定义图像 水平线 表格 标签 说明 … 定义表格 … 定义表格中的表头单元格 … 定义表格中的行 … 定义表格中的单元 其他 标签 说明 … 定义供用户输入的 HTML 表单 定义框架集的窗口或框架 参考 https://www.w3school.com.cn/html/html_primary.asp https://www.cnblogs.com/moije/p/6751624.html wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"前端标准与规范/css/":{"url":"前端标准与规范/css/","title":"第2节：CSS","keywords":"","body":"CSS wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"前端标准与规范/css/CSS选择器.html":{"url":"前端标准与规范/css/CSS选择器.html","title":"CSS选择器","keywords":"","body":"CSS选择器 在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。 分类 1. 基本选择器 选择器 类型 功能描述 * 通配选择器 选择文档中所有HTML元素 E 元素选择器 选择指定类型的HTML元素 #id ID选择器 选择指定ID属性值为“id”的任意类型元素 .class 类选择器 选择指定class属性值为“class”的任意类型的任意多个元素 selector1,selectorN 群组选择器 将每一个选择器匹配的元素集合并 2. 层次选择器 选择器 类型 功能描述 E F 后代选择器（包含选择器） 选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内 E>F 子选择器 选择匹配的F元素，且匹配的F元素所匹配的E元素的子元素 E+F 相邻兄弟选择器 选择匹配的F元素，且匹配的F元素紧位于匹配的E元素的后面 E~F 通用选择器 选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素 3. 伪类选择器 动态伪类选择器 选择器 类型 功能描述 E:link 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接描点上 E:visited 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接描点上 E:active 用户行为选择器 选择匹配的E元素，且匹配元素被激活。常用于链接描点和按钮上 E:hover 用户行为选择器 选择匹配的E元素，且用户鼠标停留在元素E上。IE6及以下浏览器仅支持a:hover E:focus 用户行为选择器 选择匹配的E元素，而且匹配元素获取焦点 目标伪类选择器 https://www.w3school.com.cn/cssref/selector_target.asp 选择器 功能描述 E:target URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。 语言伪类选择器 https://www.w3school.com.cn/cssref/selector_lang.asp 选择器 功能描述 E:lang(en) 选择带有以 \"en\" 开头的 lang 属性值的每个E 元素。 UI元素状态伪类选择器 选择器 类型 功能描述 E:checked 选中状态伪类选择器 匹配选中的复选按钮或者单选按钮表单元素 E:enabled 启用状态伪类选择器 匹配所有启用的表单元素 E:disabled 不可用状态伪类选择器 匹配所有禁用的表单元素 结构伪类选择器 选择器 功能描述 E:first-child 作为父元素的第一个子元素的元素E。与E:nth-child(1)等同 E:last-child 作为父元素的最后一个子元素的元素E。与E:nth-last-child(1)等同 E:root 选择匹配元素E所在文档的根元素。在HTML文档中，根元素始终是html，此时该选择器与html类型选择器匹配的内容相同 E F:nth-child(n) 选择父元素E的第n个子元素F。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0. E F:nth-last-child(n) 选择父元素E的倒数第n个子元素F。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同 E:nth-of-type(n) 选择父元素内具有指定类型的第n个E元素 E:nth-last-of-type(n) 选择父元素内具有指定类型的倒数第n个E元素 E:first-of-type 选择父元素内具有指定类型的第一个E元素，与E:nth-of-type(1)等同 E:last-of-type 选择父元素内具有指定类型的最后一个E元素，与E:nth-last-of-type(1)等同 E:only-child 选择父元素只包含一个子元素，且该子元素匹配E元素 E:only-of-type 选择父元素只包含一个同类型子元素，且该子元素匹配E元素 E:empty 选择没有子元素的元素，而且该元素也不包含任何文本节点 否定伪类选择器 选择器 功能描述 E:not(F) 匹配所有除元素F外的E元素 4. 伪元素选择器 伪元素的效果是需要通过添加一个实际的元素才能达到的。 选择器 功能描述 E::first-line 为E元素第一行文字使用样式 E::first-letter 为E元素中的文字的首字母或第一个字使用样式 E::before 在E元素之前插入一些内容。 E::after 在E元素之后插入一些内容 5. 属性选择器 选择器 功能描述 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 参考 https://www.w3cschool.cn/css3/css3-selector.html wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"前端标准与规范/css/BEM命名规则.html":{"url":"前端标准与规范/css/BEM命名规则.html","title":"BEM命名规则","keywords":"","body":"BEM命名规则 BEM是一种前端命名方法论，主要是针对CSS，意思是块（Block）、元素（Element）、修饰符（Modifier）的简写。这种命名方法让CSS便于统一团队开发规范和方便维护。 在选择器中，由以下三种符号来表示扩展的关系： - 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。 __ 双下划线：双下划线用来连接块和块的子元素 _ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态 type-block__element_modifier 块 一个块是设计或布局的一部分，它有具体且唯一地意义 ，要么是语义上的要么是视觉上的。 在大多数情况下，任何独立的页面元素（或复杂或简单）都可以被视作一个块。它的HTML容器会有一个唯一的CSS类名，也就是这个块的名字。 针对块的CSS类名会加一些前缀（ ui-），这些前缀在CSS中有类似命名空间ß的作用。 一个块的正式（实际上是半正式的）定义有下面三个基本原则： CSS中只能使用类名（不能是ID）。 每一个块名应该有一个命名空间（前缀） 每一条CSS规则必须属于一个块。 例如：一个自定义列表 .list 是一个块，通常自定义列表是算在 mod 类别的，在这种情况下，一个 list 列表的block写法应该为: .list 元素（element） 块中的子元素是块的子元素，并且子元素的子元素在 bem 里也被认为是块的直接子元素。一个块中元素的类名必须用父级块的名称作为前缀。 如上面的例子，li.item 是列表的一个子元素， .list{} .list .item{} .list{} .list__item{} 修饰符（modifier） 一个“修饰符”可以理解为一个块的特定状态，标识着它持有一个特定的属性。 用一个例子来解释最好不过了。一个表示按钮的块默认有三个大小：小，中，大。为了避免创建三个不同的块，最好是在块上加修饰符。这个修饰符应该有个名字（比如：size ）和值（ small，normal 或者 big ）。 如上面的例子中，表示一个选中的列表，和一个激活的列表项 .list{} .list.select{} .list .item{} .list .item.active{} .list{} .list_select{} .list__item{} .list__item_active{} BEM 解决问题 组件之间的完全解耦，不会造成命名空间的污染，如：.mod-xxx ul li 的写法带来的潜在的嵌套风险。 性能 BEM 命名会使得 Class 类名变长，但经过 gzip 压缩后这个带宽开销可以忽略不计 参考 https://juejin.im/post/6844903672162304013 https://github.com/Tencent/tmt-workflow/wiki/%E2%92%9B-%5B%E8%A7%84%E8%8C%83%5D--CSS-BEM-%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"前端标准与规范/css/常用单位.html":{"url":"前端标准与规范/css/常用单位.html","title":"常用单位","keywords":"","body":"px、em、rem、%、vw、vh、vm 这些单位的区别 px px就是像素，也是我们现在经常使用的基本单位，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点。 em em参考物是父元素的font-size，默认字体大小是16px，所以1em不是固定值，因为它会继承父元素的字体大小 rem rem参考物是相对于根元素，我们在使用时可以在根元素设置一个参考值即可，相对于em使用，减少很大运算工作量，例：html大小为10px，12rem就是120px % % 是相对于父元素的大小设定的比率，position:absolute;的元素是相对于已经定位的父元素，position：fixed；的元素是相对可视窗口 vw(viewpoint Width) vm相对于视口的宽度。视口被均分为100单位 h1 { font-size: 8vw; } vh(viewpoint Height) 1vh 等于1/100的视口高度。 vm(vmin) vmin 是当前 vm 和 vh 中较小的一个值，也就是说，是可视区域较小的一边的1/100的长度； 参考 https://juejin.im/post/5ce59380f265da1b5d578268 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"前端标准与规范/css/清除浮动.html":{"url":"前端标准与规范/css/清除浮动.html","title":"清除浮动","keywords":"","body":"清除浮动 https://juejin.im/post/59e7190bf265da4307025d91 https://juejin.im/post/5cc536775188252dcf5d515a 清除浮动的方法 浮动元素会脱离文档流，导致父元素塌陷； 利用clear样式 clear: both; 父元素结束标签之前插入清除浮动的块级元素 在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度。 改块级元素上添加clear: both; 利用伪元素(clearfix) 父级元素的最后，添加了一个:after伪元素，通过清除伪元素的浮动，达到撑起父元素高度的目的。注意到该伪元素的display值为block，即，它是一个不可见的块级元素（有的地方使用table，因为table也是一个块级元素）。 利用overflow清除浮动 在父级元素上添加了一个值为auto的overflow属性，父元素的高度立即被撑起，将浮动元素包裹在内。 给父元素设定固定的高度 br标签清除浮动 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/JavaScript/":{"url":"编程语言/JavaScript/","title":"第1节：JavaScript","keywords":"","body":"JavaScript wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/JavaScript/闭包.html":{"url":"编程语言/JavaScript/闭包.html","title":"闭包","keywords":"","body":"闭包 https://juejin.im/post/5dc6449ae51d452bd321252c https://juejin.im/post/590159d8a22b9d0065c2d918 闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 函数一直保持有对外部函数中作用域的访问权限 在一个函数里边再定义一个函数。这个内部函数一直保持有对外部函数中作用域的访问权限(小盒子一直可以有大盒子的访问权限) 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 闭包的作用 保护作用 团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过 return 或 window.xxx 的方式暴露在全局下。 保存作用 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/JavaScript/防抖与节流.html":{"url":"编程语言/JavaScript/防抖与节流.html","title":"防抖与节流","keywords":"","body":"防抖与节流 防抖 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 方法实现 function debounce(fn, delay) { var timer; return function(args) { var _this = this; var _args = args; clearTimeout(timer); timer = setTimeout(function() { fn.apply(_this, _args); }, delay) } } // 箭头函数 function debounce(fn, delay) { let timer; return (...args)=>{ clearTimeout(timer) timer = setTimeout(()=>{ fn(...args) }, delay) } } 节流 指定时间间隔内只会执行一次任务； 方法实现 function throttle(fn, threshhold) { var timer; var lastTime = new Date(); return function(args) {~~~~ var _this = this; var _args = args; var now = new Date(); clearTimeout(timer) if (now - lastTime >= threshhold) { fn.apply(_this, _args); lastTime = now; } else { timer = setTimeout(function() { fn.apply(_this, _args); }, threshhold) } } } //箭头函数 function throttle(fn, delay) { let timer; let threshTime = new Date();; return (...args) => { let now = new Date(); clearTimeout(timer); if(threshTime && now - threshTime > delay) { threshTime = now; fn(...args); } else { timer = setTimeout(()=>{ fn(...args) }, delay); } } } wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/JavaScript/事件机制.html":{"url":"编程语言/JavaScript/事件机制.html","title":"事件机制","keywords":"","body":"事件机制 https://juejin.im/post/5aba6a7cf265da23830aebb6 一、事件绑定 在dom元素中直接绑定 js代码中绑定 document.getElementById(\"btn\").onclick = function(){ alert(\"hello world!\");} 绑定事件监听函数 addEventListener() 或 attachEvent() 二、事件监听 3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。 （1）事件冒泡：指事件按照从最特定的事件目标到最不特定的事件目标的顺序触发。通俗一点，在html文档中，DOM节点成呈树状结构，从最特点的事件目标即直接发生的DOM节点到最不特点发生的事件目标即html的document对象传递，这个过程称为事件冒泡。 （2）事件捕获：事件从最不精确的document对象开始触发，到最特定最精确的事件目标。简而言之，就是和事件冒泡完全相反的两个动作。 （3）DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 三、事件委托 事件委托就是利用冒泡的原理，把事件加给父元素或祖先元素上，触发执行效果。事件委托的有点，可以避免多个同类型节点添加同一事件处理，减少内存占用，提高事件的处理速度，优化网页性能。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/JavaScript/事件循环.html":{"url":"编程语言/JavaScript/事件循环.html","title":"事件循环","keywords":"","body":"浏览器事件循环 https://juejin.im/post/5e5c7f6c518825491b11ce93 javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。 单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。 而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。 执行栈 当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。 事件队列 js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 异步任务被分为两类：微任务（micro task）和宏任务（macro task）。 以下事件属于宏任务： script(整体代码) setInterval() setTimeout() setImmediate I/O UI render 以下事件属于微任务 process.nextTick Promise Async/Await(实际就是promise) MutationObserver(html5新特性) 当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 node事件循环 外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段. poll 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。 check check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。 process.nextTick process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/JavaScript/函数劫持.html":{"url":"编程语言/JavaScript/函数劫持.html","title":"函数劫持","keywords":"","body":"函数劫持 https://juejin.im/post/5e61fdfc6fb9a07caf44685c 函数劫持的意思是在一个函数运行之前把它劫持下来，添加我们想要的功能，然后再调用原来的函数执行。这也是常见的钩子函数的原理之一。 应用 XSS攻击经常使用alert测试是否存在跨站，所以可以通过劫持alert函数来监测是否有人在攻击你的网站。在监测的页面劫持alert函数，记录调用情况。 function report(caller) { var img=new Image(); img.src=`http://www.site.com/getReport.php?caller=${encodeURIComponent(caller)}`; } var _alert = window.alert window.alert = function(s) { report(alert.caller) _alert(s) } 自定义业务功能。业务代码经常会有新需求的加入，对原代码进行修改匹配，常常比较耗费时间，这个时候就可以使用函数劫持，在不修改原业务逻辑的前提下，增加新功能。 判断某个函数是否被劫持 function foo() {console.log(foo);} alert.toString() // \"function alert() { [native code] }\" foo.toString() // \"function foo() {console.log(foo);}\" 对于native代码内置函数如alert，输出打印时会显示为[native code]，而自定义的函数会显示函数定义的内容，通过这个方法可以检查函数是否被劫持。 注意到有一种伪装成native function的方式如下： var fakeAlert = (function(){}).bind(null); console.log(window.alert.toString()); // function alert() { [native code] } console.log(fakeAlert.toString()); // function () { [native code] } bind(null)伪装后的函数不带函数名，所以更严格的检查需要检查函数名是否为空。 如何反劫持 通常劫持的都是一些可以向用户反馈信息的API，如alert、eval、console.log等。这些native代码通常难以还原，所以可以通过还原出一个纯净的环境iframe，在iframe中调用相关函数。 function createIframe(w) { var d = w.document; var newIframe = d.createElement(\"iframe\"); newIframe.style.width = 0; newIframe.style.height = 0; d.body.appendChild(newIframe); newIframe.contentWindow.document.write(\"\"); return newIframe; } function injectScriptIntoIframe(f, proc) { var d = f.contentWindow.document; var s = \"\\n(\" + proc.toString() + \")();\\n\"; d.write(s); } 举个例子，对于涉及到反馈信息的API可以封装到函数中，调用方法在iframe中执行： // 将信息相关封装到函数中，在iframe中调用 function payload() { // your code goes here } var f = createIframe(top); injectScriptIntoIframe(f, payload); wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/JavaScript/二进制数组.html":{"url":"编程语言/JavaScript/二进制数组.html","title":"二进制数组","keywords":"","body":"二进制数组 https://javascript.ruanyifeng.com/stdlib/arraybuffer.html ArrayBuffer对象、TypedArray对象、DataView对象是JavaScript操作二进制数据的一个接口。这些对象早就存在，属于独立的规格，ES6将它们纳入了ECMAScript规格，并且增加了新的方法。 这些对象原始的设计目的，与WebGL项目有关。所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。 二进制数组由三个对象组成。 （1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。 （2) TypedArray对象：用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float32Array（32位浮点数）数组视图等等。 （3）DataView对象：用来生成内存的视图，可以自定义格式和字节序，比如第一个字节是Uint8（无符号8位整数）、第二个字节是Int16（16位整数）、第三个字节是Float32（32位浮点数）等等。 简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray对象代表确定类型的二进制数据，DataView对象代表不确定类型的二进制数据。它们支持的数据类型一共有9种（DataView对象支持除Uint8C以外的其他8种）。 1. ArrayBuffer ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。 为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。 var buf = new ArrayBuffer(32); var dataView = new DataView(buf); dataView.getUint8(0) // 0 另一种TypedArray视图，与DataView视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。 var buffer = new ArrayBuffer(12); var x1 = new Int32Array(buffer); x1[0] = 1; var x2 = new Uint8Array(buffer); x2[0] = 2; x1[0] // 2 属性及方法 byteLength：返回所分配的内存区域的字节长度 slice：允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。 isView：返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例 2. TypedArray ArrayBuffer对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。ArrayBuffer有两种视图，一种是TypedArray视图，另一种是DataView视图，两者的区别主要是字节序，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。 目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。 Int8Array：8位有符号整数，长度1个字节。 Uint8Array：8位无符号整数，长度1个字节。 Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。 Int16Array：16位有符号整数，长度2个字节。 Uint16Array：16位无符号整数，长度2个字节。 Int32Array：32位有符号整数，长度4个字节。 Uint32Array：32位无符号整数，长度4个字节。 Float32Array：32位浮点数，长度4个字节。 Float64Array：64位浮点数，长度8个字节。 // 创建一个8字节的ArrayBuffer var b = new ArrayBuffer(8); // 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾 var v1 = new Int32Array(b); // 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾 var v2 = new Uint8Array(b, 2); // 创建一个指向b的Int16视图，开始于字节2，长度为2 var v3 = new Int16Array(b, 2, 2); 属性及方法 BYTES_PER_ELEMENT： 表示这种数据类型占据的字节数。 Int8Array.BYTES_PER_ELEMENT // 1 Uint8Array.BYTES_PER_ELEMENT // 1 Int16Array.BYTES_PER_ELEMENT // 2 Uint16Array.BYTES_PER_ELEMENT // 2 Int32Array.BYTES_PER_ELEMENT // 4 Uint32Array.BYTES_PER_ELEMENT // 4 Float32Array.BYTES_PER_ELEMENT // 4 Float64Array.BYTES_PER_ELEMENT // 8 3. DataView DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。 DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]); DataView实例提供8个方法读取内存。 getInt8：读取1个字节，返回一个8位整数。 getUint8：读取1个字节，返回一个无符号的8位整数。 getInt16：读取2个字节，返回一个16位整数。 getUint16：读取2个字节，返回一个无符号的16位整数。 getInt32：读取4个字节，返回一个32位整数。 getUint32：读取4个字节，返回一个无符号的32位整数。 getFloat32：读取4个字节，返回一个32位浮点数。 getFloat64：读取8个字节，返回一个64位浮点数。 var buffer = new ArrayBuffer(24); var dv = new DataView(buffer); // 从第1个字节读取一个8位无符号整数 var v1 = dv.getUint8(0); // 从第2个字节读取一个16位无符号整数 var v2 = dv.getUint16(1); // 从第4个字节读取一个16位无符号整数 var v3 = dv.getUint16(3); // 小端字节序 var v1 = dv.getUint16(1, true); // 大端字节序 var v2 = dv.getUint16(3, false); // 大端字节序 var v3 = dv.getUint16(3); DataView视图提供8个方法写入内存。 setInt8：写入1个字节的8位整数。 setUint8：写入1个字节的8位无符号整数。 setInt16：写入2个字节的16位整数。 setUint16：写入2个字节的16位无符号整数。 setInt32：写入4个字节的32位整数。 setUint32：写入4个字节的32位无符号整数。 setFloat32：写入4个字节的32位浮点数。 setFloat64：写入8个字节的64位浮点数。 // 在第1个字节，以大端字节序写入值为25的32位整数 dv.setInt32(0, 25, false); // 在第5个字节，以大端字节序写入值为25的32位整数 dv.setInt32(4, 25); // 在第9个字节，以小端字节序写入值为2.5的32位浮点数 dv.setFloat32(8, 2.5, true); 4.二进制数组的应用 AJAX 传统上，服务器通过AJAX操作只能返回文本数据，即responseType属性默认为text。XMLHttpRequest第二版XHR2允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。 Canvas 网页Canvas元素输出的二进制像素数据，就是类型化数组。 WebSocket WebSocket可以通过ArrayBuffer，发送或接收二进制数据。 Fetch API Fetch API取回的数据，就是ArrayBuffer对象。 File API 如果知道一个文件的二进制数据类型，也可以将这个文件读取为ArrayBuffer对象。 5. ArrayBuffer和Array区别 数组里面可以放数字、字符串、布尔值以及对象和数组等，ArrayBuffer放0和1组成的二进制数据 数组放在堆中，ArrayBuffer则把数据放在栈中（所以取数据时后者快） ArrayBuffer初始化后固定大小，数组则可以自由增减。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/ES6/":{"url":"编程语言/ES6/","title":"第2节：ES6","keywords":"","body":"ES6 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/ES6/变量提升.html":{"url":"编程语言/ES6/变量提升.html","title":"变量提升","keywords":"","body":"变量提升(hoisting)及暂时死区（TDZ，Temporal Dead Zone） 函数声明和变量声明总是会被解释器悄悄地被\"提升\"到方法体的最顶部。 JavaScript 只有声明的变量会提升，初始化的不会。 事实上所有的声明（function, var, let, const, class）都会被“提升”。但是只有使用var关键字声明的变量才会被初始化undefined值，而let和const声明的变量则不会被初始化值。 1、所有申明都会被提升到作用域的最顶上 2、同一个变量申明只进行一次，并且因此其他申明都会被忽略 3、函数声明的优先级优于变量申明，且函数声明会连带定义一起被提升 let/const是使用区块作用域；var是使用函数作用域 在let/const声明之前就访问对应的变量与常量，会抛出ReferenceError错误；但在var声明之前就访问对应的变量，则会得到undefined TDZ 变量从仅声明未初始化状态到初始化完成之间这个等待的时间，就叫做 TDZ 暂时性死区 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/ES6/字符串新方法.html":{"url":"编程语言/ES6/字符串新方法.html","title":"字符串新方法","keywords":"","body":"字符串新方法 1. 模版字符串 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings 模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${expression}）的占位符。 // 普通字符串 `string text` // 换行 `string text line 1 string text line 2` // 插入表达式 `string text ${expression} string text` // 带标签的模板字符串 tag `string text ${expression} string text` var person = 'Mike'; var age = 28; function myTag(strings, personExp, ageExp) { var str0 = strings[0]; // \"that \" var str1 = strings[1]; // \" is a \" // There is technically a string after // the final expression (in our example), // but it is empty (\"\"), so disregard. // var str2 = strings[2]; var ageStr; if (ageExp > 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } return str0 + personExp + str1 + ageStr; } var output = myTag`that ${ person } is a ${ age }`; console.log(output); // that Mike is a youngster indexOf()和lastIndexOf() indexOf()方法返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。区分大小写 str.indexOf(searchValue [, fromIndex]) \"Blue Whale\".indexOf(\"Blue\") // 返回 0 \"Blue Whale\".indexOf(\"Blute\") // 返回 -1 \"Blue Whale\".indexOf(\"Whale\", 0) // 返回 5 \"Blue Whale\".indexOf(\"Whale\", 5) // 返回 5 \"Blue Whale\".indexOf(\"\", -1) // 返回 0 \"Blue Whale\".indexOf(\"\", 9) // 返回 9 \"Blue Whale\".indexOf(\"\", 10) // 返回 10 \"Blue Whale\".indexOf(\"\", 11) // 返回 10 lastIndexOf() 方法返回调用String 对象的指定值最后一次出现的索引，在一个字符串中的指定位置 fromIndex处从后向前搜索。如果没找到这个特定值则返回-1。用法与indexOf类似。 includes() includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。区分大小写 str.includes(searchString[, position]) 'Blue Whale'.includes('blue'); // returns false startsWith()和endsWith() startsWith() 方法用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false。 str.startsWith(searchString[, position]) const str1 = 'Saturday night plans'; console.log(str1.startsWith('Sat')); // expected output: true console.log(str1.startsWith('Sat', 3)); // expected output: false endsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。 repeat repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。 \"abc\".repeat(-1) // RangeError: repeat count must be positive and less than inifinity \"abc\".repeat(0) // \"\" \"abc\".repeat(1) // \"abc\" \"abc\".repeat(2) // \"abcabc\" \"abc\".repeat(3.5) // \"abcabcabc\" 参数count将会被自动转换成整数. \"abc\".repeat(1/0) // RangeError: repeat count must be positive and less than inifinity padStart()和padEnd() padStart() 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。 str.padStart(targetLength [, padString]) 'abc'.padStart(10); // \" abc\" 'abc'.padStart(10, \"foo\"); // \"foofoofabc\" 'abc'.padStart(6,\"123465\"); // \"123abc\" 'abc'.padStart(8, \"0\"); // \"00000abc\" 'abc'.padStart(1); // \"abc\" padEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。 matchAll https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。 const regexp = /t(e)(st(\\d?))/g; const str = 'test1test2'; const array = [...str.matchAll(regexp)]; console.log(array[0]); // expected output: Array [\"test1\", \"e\", \"st1\", \"1\"] console.log(array[1]); // expected output: Array [\"test2\", \"e\", \"st2\", \"2\"] wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/ES6/Proxy.html":{"url":"编程语言/ES6/Proxy.html","title":"Proxy","keywords":"","body":"Proxy代理 Proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 对目标对象的操作之前提供了拦截，可以对外界的操作进行过滤和改写，修改某些操作的默认行为，这样我们可以不直接操作对象本身，而是通过操作对象的代理对象来间接来操作对象，达到预期的目的 let proxy = new Proxy(target, handler); 参数 target 是用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）, 参数 handler 也是一个对象，其属性是当执行一个操作时定义代理的行为的函数，也就是自定义的行为。 Proxy 的基本用法就如同上面这样，不同的是 handler 对象的不同，handler 可以是空对象 {} ，则表示对 proxy 操作就是对目标对象 target 操作 handler 不能 设置为 null ，会抛出一个错误——Cannot create proxy with a non-object as target or handler！ API handler.get(target,property,receiver) 用于拦截对象的读取属性操作，target 是指目标对象，property 是被获取的属性名 ， receiver 是 Proxy 或者继承 Proxy 的对象，一般情况下就是 Proxy 实例。 let proxy = new Proxy({},{ get : function (target,prop) { console.log(`get ${prop}`); return 10; } }) console.log(proxy.a) // get a // 10 handler.set(target, property, value, receiver) 用于拦截设置属性值的操作，参数于 get 方法相比，多了一个 value ，即要设置的属性值 let obj = {}; Object.defineProperty(obj, \"count\", { configurable: false, enumerable: false, value: 10, writable: false }); let proxy = new Proxy(obj,{ set : function (target,prop,value) { target[prop] = 20; } }) proxy.count = 20 ; console.log(proxy.count) // 10 .apply(target, thisArg, argumentsList) 用于拦截函数的调用，共有三个参数，分别是目标对象（函数）target，被调用时的上下文对象 thisArg 以及被调用时的参数数组 argumentsList，该方法可以返回任何值。 function sum(a, b) { return a + b; } const handler = { apply: function(target, thisArg, argumentsList) { console.log(`Calculate sum: ${argumentsList}`); return target(argumentsList[0], argumentsList[1]) * 2; } }; let proxy = new Proxy(sum, handler); console.log(sum(1, 2)); // 3 console.log(proxy(1, 2)); // Calculate sum：1,2 // 6 handler.construct(target, argumentsList, newTarget) construct 用于拦截 new 操作符，为了使 new 操作符在生成的 Proxy对象上生效，用于初始化代理的目标对象自身必须具有[[Construct]]内部方法；它接收三个参数，目标对象 target ，构造函数参数列表 argumentsList 以及最初实例对象时，new 命令作用的构造函数，即下面例子中的 p。 let p = new Proxy(function() {}, { construct: function(target, argumentsList, newTarget) { console.log(newTarget === p ); // true console.log('called: ' + argumentsList.join(', ')); // called：1,2 return { value: ( argumentsList[0] + argumentsList[1] )* 10 }; } }); console.log(new p(1,2).value); // 30 handler.has(target,prop) has方法可以看作是针对 in 操作的钩子，当我们判断对象是否具有某个属性时，这个方法会生效，典型的操作就是 in ,改方法接收两个参数 目标对象 target 和 要检查的属性 prop，并返回一个 boolean 值。 let p = new Proxy({}, { has: function(target, prop) { if( prop[0] === '_' ) { console.log('it is a private property') return false; } return true; } }); console.log('a' in p); // true console.log('_a' in p ) // it is a private property // false 参考 https://juejin.im/post/5bfcbab0518825741e7bd67f wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/通用知识/":{"url":"编程语言/通用知识/","title":"第3节：通用知识","keywords":"","body":"通用知识 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"编程语言/通用知识/常用编程命名规范.html":{"url":"编程语言/通用知识/常用编程命名规范.html","title":"常用编程命名规范","keywords":"","body":"常用编程命名规范 01 匈牙利命名法 是电脑程序设计中的一种变量命名规则)，此命名法又可细分为：系统匈牙利命名法和匈牙利应用命名法。 系统命名法与应用命名法的区别在于前缀的目的。 在系统匈牙利命名法中，前缀代表了变量的实际数据类型。例如： lAccountNum：变量是一个长整数（\"l\"）; arru8NumberList：变量是一个无符号8位整型数组（\"arru8\"）; szName：变量是一个零结束字符串（\"sz\"），这是西蒙尼最开始建议的前缀之一。 匈牙利应用命名法不表示实际数据类型，而是给出了变量目的的提示，或者说它代表了什么。 rwPosition：变量代表一个行（\"rw\"）。 usName：变量代表一个非安全字符串（\"us\"），需要在使用前处理。 strName：变量代表一个包含名字的字符串（\"str\"）但是没有指明这个字符串是如何实现的。 02 驼峰式命名法 驼峰式命名法，又叫小驼峰式命名法。 该命名规范，要求第一个单词首字母小写，后面其他单词首字母大写，简单粗暴易学易用。 03 帕斯卡命名法 帕斯卡命名法，又叫大驼峰式命名法。 与小驼峰式命名法的最大区别在于，每个单词的第一个字母都要大写。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"算法与数据结构/排序算法.html":{"url":"算法与数据结构/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 一、冒泡排序 复杂度：O(n2) 代码实现 public static void sort(int arr[]){ for( int i = 0 ; i 冒泡优化 冒泡有一个最大的问题就是这种算法不管不管你有序还是没序，闭着眼睛把你循环比较了再说。 针对这个问题，我们可以设定一个临时遍历来标记该数组是否已经有序，如果有序了就不用遍历了。 public static void sort(int arr[]){ for( int i = 0;i 二、选择排序 复杂度：O(n2) 首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。 代码实现 public static void sort(int arr[]){ for( int i = 0;i 三、插入排序 复杂度：O(n2) 代码实现 function insertSort(arr) { let length = arr.length; for(let i = 1; i 0; j--) { if(temp >= arr[j-1]) { break; // 当前考察的数大于前一个数，证明有序，退出循环 } arr[j] = arr[j-1]; // 将前一个数复制到后一个数上 } arr[j] = temp; // 找到考察的数应处于的位置 } return arr; } 四、希尔排序 也称作“缩小增量排序”，是插入排序的一种更高效的改进版本。 代码实现 public static void sort(int[] arr) { int length = arr.length; //区间 int gap = 1; while (gap 0) { for (int i = gap; i = 0 && arr[j] > tmp) { arr[j + gap] = arr[j]; j -= gap; } arr[j + gap] = tmp; } gap = gap / 3; } } 五、归并排序 将一个数组一刀切两半，递归切，直到切成单个元素，然后重新组装合并，单个元素合并成小数组，两个小数组合并成大数组，直到最终合并完成，排序完毕。 复杂度： O(nlogn) 代码实现 自顶向下 function mergeSort(list) { if(list.length 自底向上 // 自底向上 function mergeSort2(list) { const len = list.length; if(len 六、快速排序 快速排序的核心思想也是分治法，分而治之。它的实现方式是每次从序列中选出一个基准值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列。 代码实现 function fastSort(list) { if(list.length 复杂度 快速排序的时间复杂度和归并排序一样，O(n log n)，但这是建立在每次切分都能把数组一刀切两半差不多大的前提下，如果出现极端情况，比如排一个有序的序列，如[ 9，8，7，6，5，4，3，2，1 ]，选取基准值 9 ，那么需要切分 n - 1 次才能完成整个快速排序的过程，这种情况下，时间复杂度就退化成了 O(n2)，当然极端情况出现的概率也是比较低的。 七、堆排序 复杂度：O(nlogn) 例题：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/comments/ function ListNode(val) { this.val = val; this.next = null; } var mergeKLists = function(lists) { let pq = new MinHeap(lists.length) for(let i = 0; i 0 && this.data[k].val 八、计数排序 复杂度 复杂度为 O(n + m )，m 指的是数据量，说的简单点，计数排序算法的时间复杂度约等于 O(n)，快于任何比较型的排序算法。 计数排序只适用于正整数并且取值范围相差不大的数组排序使用，它的排序的速度是非常可观的。 九、桶排序 复杂度 在额外空间充足的情况下，尽量增大桶的数量，极限情况下每个桶只有一个数据时，或者是每只桶只装一个值时，完全避开了桶内排序的操作，桶排序的最好时间复杂度就能够达到 O(n)。 十、基数排序 数据按位数切割成不同的数字，然后按每个位数分别比较。 参考 https://juejin.im/post/5cff49e75188257a6b40de80 https://h3manth.com/javascript-sorting/ wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"算法与数据结构/搜索.html":{"url":"算法与数据结构/搜索.html","title":"搜索","keywords":"","body":"搜索 搜索算法实际上是根据初始条件和扩展规则构造搜索树寻找符合目标节点的过程。所有的搜索算法本质上看都可以划分成两个部分——控制结构（扩展节点的方式）和产生系统（扩展节点），而所有的算法优化和改进主要都是通过修改其控制结构来完成的。 其实，在这样的思考过程中，我们已经不知不觉地将一个具体的问题抽象成了一个图论的模型——树，即搜索算法的使用第一步在于搜索树的建立。 一、广度优先搜索（Breadth-First-Search, BFS） 广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记录正在访问的顶点的下一层顶点 例题：https://leetcode-cn.com/problems/word-ladder/ /** * @param {string} beginWord * @param {string} endWord * @param {string[]} wordList * @return {number} */ var ladderLength = function (beginWord, endWord, wordList) { let wordMap = new Map(); // 根据通用状态生成邻接关系 for (let item of wordList) { for (let index in item) { index = parseInt(index) let key = item.substring(0, index) + '_' + item.substring(index + 1) if(wordMap.has(key)) { wordMap.get(key).push(item) }else{ wordMap.set(key, [item]) } } } // BFS辅助队列 let Queue = []; Queue.push({word: beginWord, level: 1}) // 访问序列 let visited = new Map(); // 队列非空 while(Queue.length !== 0) { let node = Queue.shift(); let nodeWord = node.word; let level = node.level; if(nodeWord === endWord) { return level; } // 判断每一层是否包含目标节点，如果没有，并且节点未被访问，则节点入队，标记为已读 for(let i = 0; i 二、深度优先搜索（Depth-First-Search，DFS ） 深度优先搜索算法 是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。 在树的遍历中，我们可以用 DFS 进行 前序遍历，中序遍历和后序遍历。在这三个遍历顺序中有一个共同的特性：除非我们到达最深的结点，否则我们永远不会回溯。这也是 DFS 和 BFS 之间最大的区别，BFS永远不会深入探索，除非它已经在当前层级访问了所有结点。 有两种实现 DFS 的方法。一种方法是进行递归，另一种是使用栈。 例题：https://leetcode-cn.com/problems/keys-and-rooms/ /** * @param {number[][]} rooms * @return {boolean} */ var canVisitAllRooms = function(rooms) { let seen = new Array(rooms.length) seen[0] = true let stack = [] stack.push(0); while(stack.length !== 0) { let node = stack.pop(); for(let item of rooms[node]) { if(!seen[item]) { seen[item] = true; stack.push(item) } } } for(let i = 0; i wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"算法与数据结构/链表逆序.html":{"url":"算法与数据结构/链表逆序.html","title":"链表逆序","keywords":"","body":"创建单链表及倒序单链表 function Node(data){ this.data = data; //数据 this.next = null; //链接 } function List(){ this.head = new Node(\"head\"); //创建一个头节点 this.addFirst = addFirst; //从头部插入一个节点，从而创建链表 this.display = display; //显示链表的数据 this.listReverse = listReverse; //倒序单链表 } //从链表头部插入一个节点，newEle是新节点的数据 function addFirst(newEle){ var newNode = new Node(newEle); //如果链表为空，则直接加在头节点后面 if(this.head.next === null){ this.head.next = newNode; }else{//如果链表不为空，则在头节点与第一个节点之间插入新节点 var first = this.head.next; newNode.next = first; this.head.next = newNode; } } //倒序单链表，将原链表中的节点从头部开始一个个删除并加到新链表中，最后返回新链表 function listReverse(){ var pHead = this.head; var pre = null; var next = null; while (pHead !== null) { next = pHead.next; pHead.next = pre; pre = pHead; pHead = next; } return pre; } //显示 function display(){ var currNode = this.head; while(currNode.next !== null){ console.log(currNode.next.data); currNode = currNode.next; } } wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"算法与数据结构/分治.html":{"url":"算法与数据结构/分治.html","title":"分治","keywords":"","body":"分治 二分查找 二分查找也称折半查找（Binary Search），是一种在有序数组中查找某一特定元素的搜索算法。搜索 过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 时间复杂度：O(logn) 非递归实现 function binarySearch(nums, target) { if(!nums || nums.length === 0) { return -1 } let left = 0; let right = nums.length -1; while(left target) { right = middle - 1; }else if(nums[middle] 递归实现 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"框架/概述/":{"url":"框架/概述/","title":"第1节：概述","keywords":"","body":"wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"框架/概述/模块化.html":{"url":"框架/概述/模块化.html","title":"模块化","keywords":"","body":"前端模块化 https://juejin.im/post/5aaa37c8f265da23945f365c 模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。 一、CommonJS CommonJS规范为CommonJS小组所提出，目的是弥补JavaScript在服务器端缺少模块化机制，NodeJS、webpack都是基于该规范来实现的。 Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。 // 定义模块math.js var basicNum = 0; function add(a, b) { return a + b; } module.exports = { //在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum } // 引用自定义的模块时，参数包含路径，可省略.js var math = require('./math'); math.add(2, 5); // 引用核心模块时，不需要带路径 var http = require('http'); http.createService(...).listen(3000); commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 特点： 所有代码都运行在模块作用域，不会污染全局作用域； 模块是同步加载的，即只有加载完成，才能执行后面的操作； 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存； CommonJS输出是值的拷贝(即，require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。 二、AMD和RequireJS AMD一开始是CommonJS规范中的一个草案，全称是Asynchronous Module Definition，即异步模块加载机制。后来由该草案的作者以RequireJS实现了AMD规范，所以一般说AMD也是指RequireJS。 AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。 /** 网页中引入require.js及main.js **/ /** main.js 入口文件/主模块 **/ // 首先用config()指定各模块路径和引用名 require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", } }); // 执行基本操作 require([\"jquery\",\"underscore\"],function($,_){ // some code here }); 引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。 // 定义math.js模块 define(function () { var basicNum = 0; var add = function (x, y) { return x + y; }; return { add: add, basicNum :basicNum }; }); // 定义一个依赖underscore.js的模块 define(['underscore'],function(_){ var classify = function(list){ _.countBy(list,function(num){ return num > 30 ? 'old' : 'young'; }) }; return { classify :classify }; }) // 引用模块，将模块放在[]内 require(['jquery', 'math'],function($, math){ var sum = math.add(10,20); $(\"#sum\").html(sum); }); 特点： 依赖前置，提前执行 三、CMD和SeaJS CMD是SeaJS在推广过程中生产的对模块定义的规范，在Web浏览器端的模块加载器中，SeaJS与RequireJS并称，SeaJS作者为阿里的玉伯。 //a.js /* * define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串， * factory 为对象、字符串时，表示模块的接口就是该对象、字符串。 * define 也可以接受两个以上参数。字符串 id 表示模块标识，数组 deps 是模块依赖. */ define(function(require, exports, module) { var $ = require('jquery'); exports.setColor = function() { $('body').css('color','#333'); }; }); //b.js //数组中声明需要加载的模块，可以是模块名、js文件路径 seajs.use(['a'], function(a) { $('#el').click(a.setColor); }); 特点：依赖就近，延迟执行 四、ES6 Module ES6 Module是ES6中规定的模块体系，相比上面提到的规范， ES6 Module有更多的优势，有望成为浏览器和服务器通用的模块解决方案。 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 /** 定义模块 math.js **/ var basicNum = 0; var add = function (a, b) { return a + b; }; export { basicNum, add }; /** 引用模块 **/ import { basicNum, add } from './math'; function test(ele) { ele.textContent = add(99 + basicNum); } 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 /** export default **/ //定义输出 export default { basicNum, add }; //引入 import math from './math'; function test(ele) { ele.textContent = math.add(99 + math.basicNum); } ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 五、ES6模块与CommonJS模块的差异 1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"框架/概述/Module的加载实现.html":{"url":"框架/概述/Module的加载实现.html","title":"Module的加载实现","keywords":"","body":"Module的加载实现 https://es6.ruanyifeng.com/#docs/module-loader 一、浏览器加载 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。 上面代码中，标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。 defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 浏览器加载 ES6 模块，也使用标签，但是要加入type=\"module\"属性。 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。 二、ES6模块与CommonJS模块差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 　三、Node.js加载 .mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置。 四、循环加载 CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。 ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"框架/概述/MVVM.html":{"url":"框架/概述/MVVM.html","title":"MVVM","keywords":"","body":"MVVM https://segmentfault.com/a/1190000015895017 https://segmentfault.com/a/1190000015581922 Model-ViewModel-View-Controller 采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel， 与MVC框架的主要区别有两点： 1、实现数据与视图的分离 2、通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了。 MVVM的实现原理： MVVM的实现主要是三个核心点： 响应式：vue如何监听data的属性变化 模板解析：vue的模板是如何被解析的 渲染：vue模板是如何被渲染成HTML的 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"网络/TCP.html":{"url":"网络/TCP.html","title":"TCP","keywords":"","body":"TCP 一、建立连接 第一次：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次：服务器收到SYN包，向客户端返回ACK（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态； 第三次：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据，也就是ESTABLISHED状态。 三次握手保证了不会建立无效的连接，从而浪费资源。 二、断开连接 第一次： TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。 第二次：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 第三次：服务器关闭客户端的连接，发送一个FIN给客户端。 第四次：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"网络/HTTP.html":{"url":"网络/HTTP.html","title":"HTTP","keywords":"","body":"HTTP 1.0 1.1 2.0 区别 HTTP1.0和HTTP1.1的一些区别 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 HTTP 2.0 多路复用(Multiplexing) 多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。 众所周知 ，在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。 二进制分帧 在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。 众所周知 ，在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。 首部压缩（Header Compression） 服务端推送（Server Push） 服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。 比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"网络/HTTPS.html":{"url":"网络/HTTPS.html","title":"HTTPS","keywords":"","body":"HTTPS https://juejin.im/post/5e477dc551882549724e1ace 一、基础知识 对称加密算法 加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等 非对称加密算法 加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 数字签名 在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 二、HTTPS过程 证书验证阶段 浏览器发起 HTTPS 请求 服务端返回 HTTPS 证书 客户端验证证书是否合法，如果不合法则提示告警 数据传输阶段 当证书验证合法后，在本地生成随机数 通过公钥加密随机数，并把加密后的随机数传输到服务端 服务端通过私钥对随机数进行解密 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输 三、工作原理 HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 四、中间人攻击原理 SSL劫持攻击 SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据； SSL剥离攻击 将攻击者设置为中间人，之后见HTTPS范文替换为HTTP返回给浏览器，而中间人和服务器之间仍然保持HTTPS服务器。由于HTTP是明文传输的，所以中间人可以获取客户端和服务器传输数据 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"网络/http常用状态码.html":{"url":"网络/http常用状态码.html","title":"http常用状态码","keywords":"","body":"　HTTP 常用状态码（Http Status code） 状态码类别 类别 原因短语 1xx Informational(信息性状态码) 接受的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作一完成请求 4xx Client Error (客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 2XX 成功 2XX 的响应结果表明请求被正常处理了 200 OK 表示从客户端发来的请求在服务器端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主作为响应返回（即在响应中只返回首部，不会返回实体的主体部分 204 No Content 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用;对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码204来作为返回信息，从而省掉多余的数据传输。 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内; 3XX 重定向 3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI 303 See Oth 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源 304 Not Modified 该状态码表示客户端发送附带条件的请求 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系 4XX 客户端 400 Bad Request 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。 401 Unauthorization 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。 返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗 403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因 404 Not Found 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使 5XX 服务端 500 Internal Server Error 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。 503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户 参考 https://juejin.im/post/5cd2ea425188254459335583 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"网络/JSONP跨域详解.html":{"url":"网络/JSONP跨域详解.html","title":"JSONP跨域详解","keywords":"","body":"JSONP跨域详解 https://www.jianshu.com/p/e1e2920dac95 JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议 允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了 实现步骤 1. 客户端 定义获取数据后调用的回调函数 动态生成对服务端JS进行引用的代码 设置url为提供jsonp服务的url地址，并在该url中设置相关callback参数 创建script标签，并设置其src属性 把script标签加入head，此时调用开始。 2. 服务端 将客户端发送的callback参数作为函数名来包裹住JSON数据，返回数据至客户端。 AJAX与JSONP的异同 AJAX和JSONP这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jQuery和extjs等框架都把JSONP作为AJAX的一种形式进行了封装； 但AJAX和JSONP其实本质上是不同的东西。AJAX的核心是通过XmlHttpRequest获取非本页内容，而JSONP的核心则是动态添加script标签来调用服务器提供的js脚本。 所以说，其实AJAX与JSONP的区别不在于是否跨域，AJAX通过服务端代理一样可以实现跨域，JSONP本身也不排斥同域的数据的获取。 还有就是，JSONP是一种方式或者说非强制性协议，如同AJAX一样，它也不一定非要用JSON格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用JSONP提供公开服务。 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"常用技术/SSI.html":{"url":"常用技术/SSI.html","title":"服务器端内嵌 SSI","keywords":"","body":"服务器端内嵌(SSI) SSI全称是Server Side Includes，即服务器端包含，是一种基于服务器端的网页制作技术。 SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 基本原理：SSI在HTML文件中，可以通过注释行调用命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 01 主要用途 显示服务器端环境变量 将文本内容直接插入到文档中 显示WEB文档相关信息 (如文件制作日期/大小等) 直接执行服务器上的各种程序(如CGI或其他可执行程序) 设置SSI信息显示格式(如文件制作日期/大小显示方式) 02 SHTML文件 SHTML即Server-Parsed HTML。 shtml文件（还有stm、shtm文件）就是应用了SSI技术的html文件，所以在.shtml页面返回到客户端前，页面中的SSI指令将被服务器解析。可以使用SSI指令将其它文件、图片包含在页面中，也可以将其它的CGI程序包含在页面中，如.aspx文件。在给客户端返回的页面中不会包含SSI指令。如果SSI指令不能被解析，则浏览器会将其做为普通的HTML注释处理。 03 SSI基本语法 在SHTML文件中SSI标签使用的几种基本语法如下，必须注意的是其语法格式必须是以html的注释符开头、且后面紧接#符号和SSI命令，它们期间不能存在空格： 1、显示服务器端环境变量 本文档名称： 现在时间： 显示IP地址： 2、将文本内容直接插入到文档中 注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径。 3、显示WEB文档相关信息(如文件制作日期/大小等) 文件最近更新日期： 文件的长度： 4、直接执行服务器上的各种程序(如CGI或其他可执行程序) 将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是CGI。 5、设置SSI信息显示格式(如文件制作日期/大小显示方式) 6、高级SSI可设置变量使用if条件语句 欢迎光临好易CGI工厂在淄博热线的分站http://hoyi.zb169.net。 欢迎光临好易CGI工厂在太阳城的分站http://linux.cqi.com.cn/~hoy。 欢迎光临好易CGI工厂！ 注意：用于前面指令中的反斜杠，是用来代换内部的引号，以便它们不会被解释为结束表达式。不可省略。 04 Web服务启动SSI Nginx 在Nginx中，开启SSI只需在配置文件中添加如下几项： ssi on; ssi_silent_errors off; ssi_types text/shtml; 如： server{ listen 80; server_name www.hello.com # 配置SSL ssi on; # 开启SSI支持 ssi_silent_errors on; # 默认为off，设置为on则在处理SSI文件出错时不输出错误信息 ssi_types text/html; # 需要支持的shtml 默认是 text/html location / { root html; index index.html index.htm; } } Apache 修改Apache配置文件httpd.conf： 1、确认加载include.so模块，将注释去掉： LoadModule include_module libexec/apache2/mod_include.so 2、AddType部分去掉这两段注释： AddType text/html .shtml AddOutputFilter INCLUDES .shtml 3、Directory目录权限里面找到Options Indexes FollowSymLinks，并增加Includes修改为Options Indexes FollowSymLinks Includes； 4、重新启动Apache； 05 SSI注入漏洞 SSI注入全称Server-Side Includes Injection，即服务端包含注入。在stm、shtm、shtml等Web页面中，如果用户可以从外部输入SSI标签，而输入的内容会显示到上述后缀的Web页面时，就导致可以远程在Web应用中注入脚本来执行代码。 简单点说就是攻击者可以通过外部输入SSI标签到Web页面（stm、shtm、shtml文件）来动态执行代码。 SSI注入允许远程在Web应用中注入脚本来执行代码。简单点说就是攻击者可以通过外部输入SSI语句到Web页面来动态执行代码。 防御方法 若非必须，尽量关闭服务器的SSI功能； 对用户的输入进行严格的过滤，过滤相关SSI特殊字符（,#,-,\",'）； 参考 SSI注入漏洞总结 SSI技术详解 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"其他/GIT常用指令.html":{"url":"其他/GIT常用指令.html","title":"GIT常用指令","keywords":"","body":"GIT常用指令 功能 指令 配置config git config user.name \"Administrator\" git config user.email \"root@example.com\" clone项目 git clone http://git.code.oa.com/group_path/project_path.git 创建并切换分支 git checkout –b test(分支名） 添加修改的文件到缓存区 git add 文件名 查看状态 git status 提交代码到本地仓库 git commit –m \"描述信息\" 查看历史 git log 拉取远程仓库最新代码 git pull origin test 推送代码到远程仓库 git push origin test 本地合并分支(合并前要切分支和拉最新代码) git checkout master git pull origin master git merge test 变基rebase合并（rebase后还要回到主分支merge） git checkout test git rebase master 打tag，查看tag git tag v1.0 git tag git push origin v1.0 关联远程仓库 cd existing_folder git init git remote add origin url git add . git commit -m \"init\" git push -u origin master 查看当前远程仓库地址 git remote –v http与ssh互转 git remote set-url origin http://xxxxxxx.git git remote set-url origin git@git.xxxxx.git wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"其他/npm常用指令.html":{"url":"其他/npm常用指令.html","title":"npm常用指令","keywords":"","body":"npm常用指令 配置 指令 说明 npm config list 列举已有npm配置 npm config set registry 镜像源地址 设置镜像地址 npm install -g cnpm --registry=https://registry.npm.taobao.org 使用cnpm cnpm install package-name 使用 cnpm 命令代替 npm 命令 安装模块 指令 说明 npm install 模块名 -g 全局安装 npm install 模块名 本地安装 npm install 模块名 --save 安装运行时依赖包 npm install 模块1 模块2 模块n --save 一次性安装多个依赖包 npm install 模块名 --save-dev 安装开发时依赖包 更新模块 指令 说明 npm update 模块名 更新本地模块 npm update -g 模块名 更新全局模块 卸载模块 指令 说明 npm uninstall 模块名 卸载本地模块 npm uninstall -g 模块名 卸载全局模块 查看安装 指令 说明 npm root 查看本地安装的目录 npm root -g 查看全局安装的目录 npm ls --dept 0 查看当前目录下已安装的模块 npm ls -g --dept 0 查看已安装的全局模块 npm info 模块名 查看模块的信息 其他 指令 说明 npm help 查看npm命令 npm init 初始化一个基于node的项目，会创建一个配置文件package.json npm init --yes 全部使用默认配置 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"其他/nvm常用指令.html":{"url":"其他/nvm常用指令.html","title":"nvm常用指令","keywords":"","body":"nvm常用指令 指令 说明 nvm ls-remote 列出所有可安装的版本 nvm install 安装指定的版本，nvm install v8.14.0 nvm uninstall 卸载指定的版本 nvm ls 列出所有已经安装的版本 nvm use 切换使用指定的版本 nvm current 显示当前使用的版本 nvm alias default 设置默认node版本 nvm deactivate 解除当前版本绑定 参考 https://segmentfault.com/a/1190000017391932 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "},"其他/mac常用指令.html":{"url":"其他/mac常用指令.html","title":"mac常用指令","keywords":"","body":"mac常用指令 常用操作 命令名 功能描述 举例或备注 sudo 获取root权限 sudo -s sudo lsof -i:端口号 查看端口被哪个进程占用 sudo lsof -i:8080 sudo kill -9 pid号 结束相应进程 sudo kill -9 8080 Ctr + D / exit 退出root权限 clear 清除屏幕或窗口内容 ping 给网络主机发送回应请求 ping www.baidu.com man 查看命令说明 man ls q 退出查看的命令说明 which 查看指定程序的路径 which python history 列出最近执行过的命令及编号 hostname 电脑在网络中的名称 env 显示当前所有设置过的环境变量 passwd 修改用户密码 date 显示系统的当前日期和时间 date cal 显示日历 cal time 统计程序的执行时间 time 目录和文件操作 命令名 功能描述 举例或备注 cd 进入指定文件夹路径 cd ~/Desktop pwd 显示当前的目录路径 /Users/xz/Desktop ls 显示当前目录下的内容 ls -la 显示当前目录下的详细内容 ls -A 显示当前目录下的内容 含点(.)开头的文件 mkdir 创建目录 mkdir dir_name touch file.format 创建指定格式的文件 mvdir 移动目录 mvdir dir1 dir2 mv 移动/重命名---文件/文件夹 mv dir1 dir2 MAC没有重命名的命令 rm 删除文件 或 空目录 rm -rf dir 删除一个 非空 目录 rm -rf dir rmdir 删除 空 目录 平时用得少 cp 复制文件或目录 cp file1 file2 file 显示文件类型 file file_name find 使用匹配表达式查找文件 find *.file_format open 使用默认的程序打开文件 open file_name cat 显示或连接文件内容 cat file ln 为文件创建联接 ln -s file1 file2 s 表示软联接 head 显示文件的最初几行 head -20 file_name tail 显示文件的最后几行 tail -10 file_name paste 横向拼接文件内容 paste file1 file2 diff 比较并显示两个文件的内容差异 diff file1 file2 wc 统计文件的字符数、词数和行数 wc file_name uniq 去掉文件中的重复行 uniq file_name grep 通过简单正则表达式搜索文件 文件属性 Linux系统：一切设备都可以看成是文件。如：目录、磁盘文件、管道、网络Socket、外接U盘和SD卡等； 文件属性：用户组、读、写、执行权限； 查看文件属性 XZ:ts xz$ ls -l total 82488 -rw-r--r--@ 1 xz staff 42233727 7 19 16:30 PowerBi.pbix 语法 属性 含义说明 - 文件类型 横杠表示普通文件，若为d表示文件目录 rw-r--r-- 访问权限 分3组：用户、群组和其他用户的文件访问权限； 1 文件数量 本例中仅1个文件 xz 所在用户 本例中用户名为xz staff 所在群组 本例中用户群组为staff 42233727 文件大小 本例中文件的字节数 7 19 16:30 修改日期 本例中为7-19 16:30 PowerBi.pbix 文件名称 本例中为PowerBi.pbix 修改访问权限 语法：chmod 用户 操作 权限 文件 用户：u表示用户(user)、g表示群组(group)、o表示其他用户(other)、a表示全部用户。缺失的情况下默认为所有用户； 操作：+表示增加权限、-表示取消权限、=表示赋值权限； 权限：r表示可读(read)、w表示可写(write)、x表示可执行(execute)； 文件：不指定文件名时，操作对象为当前目录下的所有文件。 示例：为user用户增加执行的权限 XZ:ts xz$ chmod u+x PowerBi.pbix XZ:ts xz$ ls -l total 82488 -rwxr--r--@ 1 xz staff 42233727 7 19 16:30 PowerBi.pbix 参考 MAC常用终端命令行 mac端口占用解决方案 wayofway all right reserved，powered by GitbookLast updated： 2021-02-24 09:22:33 "}}